#!/usr/bin/env python

import os
import urllib
import typing as t
import json
from pathlib import Path

import click
import jwt
from oauth2_cli_auth import get_access_token_with_browser_open, OAuth2ClientInfo
from dotenv import dotenv_values
from pydantic import BaseModel
import readline  # noqa


# import generated library
from generated.teaspoons_client import Configuration, ApiClient, PipelinesApi


class OAuth2ClientInfoCustomAuthUrl(OAuth2ClientInfo):
    """
    Override the default OAuth2ClientInfo to allow for a custom authorization URL
    """

    def __init__(self, client: OAuth2ClientInfo):
        self.client_id = client.client_id
        self.scopes = client.scopes
        self.authorization_url = client.authorization_url
        self.token_url = client.token_url

    def get_auth_url(client_info: OAuth2ClientInfo, redirect_uri: str) -> str:
        """
        Build authorization url for browser

        :param client_info: Info about oauth2 client
        :param redirect_uri: Callback URL
        :return: Ready to use URL
        """
        return (f"{client_info.authorization_url}"
                f"?client_id={urllib.parse(client_info.client_id)}"
                f"&redirect_uri={urllib.parse(redirect_uri)}"
                f"&scope={'+'.join(client_info.scopes)}"
                f"&response_type=code"
                f"&prompt=login")


home = Path.home()


config = dotenv_values(".env")
client_info = OAuth2ClientInfoCustomAuthUrl(OAuth2ClientInfo.from_oidc_endpoint(
    config["OAUTH_OPENID_CONFIGURATION_URI"],
    client_id=config["OAUTH_CLIENT_ID"],
    scopes=[f"openid+email+profile+{config['OAUTH_CLIENT_ID']}"]
))

# Figure out the path to the token file...there must be some way to abstract out local storage
if (config["LOCAL_STORAGE_PATH"].startswith("/")):
    token_file = f"{config['LOCAL_STORAGE_PATH']}/access_token"
else:
    token_file = f'{home}/{config["LOCAL_STORAGE_PATH"]}/access_token'


def __get_api_client(token: str) -> ApiClient:
    api_config = Configuration()
    api_config.host = config["TSPS_API_URL"]
    api_config.access_token = token
    return ApiClient(configuration=api_config)


def __validate_token(token: str) -> bool:
    try:
        # Attempt to read the token to ensure it is valid.  If it isn't, the file will be removed and None will be returned.
        # Note: to simplify, not worrying about the signature of the token since that will be verified by the backend services
        # This is just to ensure the token is expired
        jwt.decode(token, options={"verify_signature": False, "verify_exp": True})
        return True
    except Exception as e:
        return False


def __load_local_token() -> t.Optional[str]:
    try:
        with open(token_file, 'r') as f:
            token = f.read()
            if __validate_token(token):
                return token
            else:
                return None

    except FileNotFoundError:
        try:
            # Clear the token file if it isn't valid
            os.remove(token_file)
        except FileNotFoundError:
            pass

        return None


def __save_local_token(token: str):
    # Create the containing directory if it doesn't exist
    os.makedirs(os.path.dirname(token_file), exist_ok=True)
    with open(token_file, 'w') as f:
        f.write(token)


class ClientWrapper(object):
    """
    Wrapper to ensure that the user is authenticated before running the callback and that provides the low level api client to be used
    by subsequent commands
    """

    def __enter__(self):
        token = globals()['__load_local_token']()
        if not token:
            click.echo('Please authenticate first')
            # Don't love exiting here, but it's the easiest way to ensure the user is prompted to authenticate without getting a whole
            # stack trace
            exit(1)
        else:
            return globals()['__get_api_client'](token)

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass


def __pretty_print(obj: BaseModel):
    """
    Prints a pydantic model in a pretty format to the console
    """
    click.echo(json.dumps(obj.model_dump(), indent=4))

# CLI definition


@click.group()
def cli():
    pass


@cli.command()
@click.option('-t', '--token', default=False, is_flag=True, help='If specified, will ask you to provide a token manually')
def login(token: bool):
    if (token):
        # This is work around a weird behavior where python doesn't let you paste more than 1024 characters into the terminal.
        # Just importing fixes the issue...

        token = click.prompt('Please enter your access token', hide_input=False)
        if token and __validate_token(token):
            __save_local_token(token)
            return
        else:
            click.echo('Invalid token')
            return

    else:
        token = __load_local_token()
        if token:
            click.echo('Already authenticated')
            return
        token = get_access_token_with_browser_open(client_info, server_port=10444)
        __save_local_token(token)


@cli.command()
def list_pipelines():
    with ClientWrapper() as api_client:
        # NOTE: this is broken until this is merged with the different api def for the get_pipelines_result
        pipeline_client = PipelinesApi(api_client=api_client)
        pipelines = pipeline_client.get_pipelines()
        for pipeline in pipelines.pipelines.results:
            click.echo(f'{pipeline.name} - {pipeline.description}')


@cli.command()
@click.argument('name')
def get_pipeline(name: str):
    with ClientWrapper() as api_client:
        pipeline_client = PipelinesApi(api_client=api_client)
        pipeline = pipeline_client.get_pipeline_details(pipeline_name=name)
        __pretty_print(pipeline)


if __name__ == '__main__':
    cli()
